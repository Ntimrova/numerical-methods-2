import { log } from 'mathjs';  // Для обчислення логарифму

// Функція для рівняння ln(5x - 3) = 0.1x(1 + x)
const equation = (x) => log(5 * x - 3) - 0.1 * x * (1 + x);

// Метод дихотомії
// Основна ідея полягає в тому, що на кожній ітерації відрізок, 
// на якому знаходиться корінь, ділиться навпіл, і одна з половин відкидається. 
// Це повторюється до тих пір, поки відрізок не стане досить малим. 
// Точність рішення контролюється параметром tol (допустима похибка).


export const bisectionMethod = (a, b, tol) => {
  let mid;
//  Функція приймає три параметри:
// a: початкова межа інтервалу зліва.
// b: початкова межа інтервалу справа.
// tol: допустима похибка (точність).
// Змінна mid використовується для збереження середньої точки інтервалу.
  while ((b - a) / 2 > tol) {    // Цикл продовжується до тих пір, поки половина довжини інтервалу (b - a) / 2 не стане меншою за tol. 
    mid = (a + b) / 2;         // Це означає, що точність наближення до кореня перевіряється після кожної ітерації.
    if (equation(mid) === 0) return mid;  //Перевірка на точний корінь
    else if (equation(a) * equation(mid) < 0) b = mid;
// Вибір інтервалу (лівий випадок):
// Якщо знак функції в точці a і знак функції в точці mid різні (добуток значень менший за 0),
//  це означає, що корінь знаходиться між a і mid. Тому новий інтервал буде [a, mid], 
//  і b оновлюється до mid.
    else a = mid;   //Вибір інтервалу (правий випадок)
  }
  return mid;
};




// Метод Ньютона
// Ініціалізація:
// Функція приймає три параметри:
// x0: початкове наближення для кореня (точка, з якої починаються обчислення).
// tol: допустима похибка (точність наближення).
// maxIter: максимальна кількість ітерацій (за замовчуванням 1000).
// Змінна x ініціалізується значенням x0, тобто це перше наближення до кореня.
// Змінна iter відстежує кількість ітерацій.
// Функція derivative визначає похідну від рівняння, яку потрібно обчислювати на кожному кроці.
export const newtonMethod = (x0, tol, maxIter = 1000) => {
  let x = x0;
  let iter = 0;
  const derivative = (x) => 5 / (5 * x - 3) - 0.1 * (1 + 2 * x);

  while (Math.abs(equation(x)) > tol && iter < maxIter) {
    x = x - equation(x) / derivative(x);
    iter++;
  }
// Цикл виконується до тих пір, поки абсолютне значення функції equation(x)
// в поточній точці більше за задану точність tol, і кількість ітерацій не перевищує maxIter.
// Іншими словами, метод продовжує шукати корінь, поки наближення не буде досить точним 
// або поки не буде досягнута максимальна кількість ітерацій.

  return x;
};

// // Ітераційний метод
// // Функція приймає три параметри:
// // x0: початкове наближення (перша точка для початку ітерацій).
// // tol: допустима похибка (точність наближення).
// // maxIter: максимальна кількість ітерацій (за замовчуванням 1000).
// // Змінна x ініціалізується початковим значенням x0.
// // Змінна iter відстежує кількість ітерацій.
// export const iterativeMethod = (x0, tol, maxIter = 1000) => {
//   let x = x0;
//   let iter = 0;

//   const g = (x) => (log(5 * x - 3)) / (0.1 * (1 + x));

// // Опис функції перетворення:
// // Функція g(x) визначає ітераційне перетворення, яке заміняє оригінальне рівняння на вигляд x=g(x).
// // У цьому випадку функція g(x) є виразом, який використовуватиметься для наступного наближення в кожній ітерації. 
// // Вона залежить від конкретної задачі і створена так, щоб рівняння можна було вирішувати через ітерації.

//   while (Math.abs(g(x) - x) > tol && iter < maxIter) {
//     x = g(x);
//     iter++;
//   }
//   // Цикл виконується, поки різниця між поточним значенням x і новим значенням, обчисленим через функцію g(x), 
//   // більше за задану точність tol, і кількість ітерацій не перевищує maxIter.
//   // Умова перевіряє, наскільки нове значення g(x) відрізняється від старого, і цикл продовжується, 
//   // поки ця різниця не стане досить малою (точність досягнута).
  
//   return x;
// };



// Ітераційний метод для знаходження коренів рівняння
// Функція приймає три параметри:
// x0: початкове наближення (перша точка для початку ітерацій).
// tol: допустима похибка (точність наближення).
// maxIter: максимальна кількість ітерацій (за замовчуванням 1000).
// Змінна x ініціалізується початковим значенням x0.
// Змінна iter відстежує кількість виконаних ітерацій.

export const iterativeMethod = (x0, tol, maxIter = 1000) => {
  let x = x0;
  let iter = 0;
  let prevX;

  // Визначення функції g(x) для ітераційного процесу:
  const g = (x) => (Math.log(5 * x - 3)) / (0.1 * (1 + x));

  // Цикл виконується доти, поки зміна знаку не буде досягнута або кількість ітерацій не перевищить maxIter.
  do {
    prevX = x;
    x = g(x);
    iter++;
  } while (x * prevX >= 0 && iter < maxIter);

  return x;
};
  